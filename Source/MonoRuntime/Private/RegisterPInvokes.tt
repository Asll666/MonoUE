<#@ template language="C#" hostspecific="true" #>
<#@ output extension=".cpp" #>
<#@ assembly name="System.Core.dll" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections.Generic" #>
<#
var dllImportRegex = new Regex(@"\[DllImport\s*\(\s*""([^""]+)""", RegexOptions.Compiled);
var entryPointRegex = new Regex(@"EntryPoint\s*=\s*""([^""]+)""", RegexOptions.Compiled);
var nameRegex = new Regex(@"\s+(\w+)\s*\(", RegexOptions.Compiled);

var bindingsDir = Host.ResolvePath(Path.Combine("..", "..", "..", "Managed", "MonoBindings"));

var entrypoints = new HashSet<string>();

foreach (var b in Directory.EnumerateFiles (bindingsDir, "*.cs", SearchOption.AllDirectories)) {
	var lines = File.ReadAllLines(b);
	for(int i = 0; i < lines.Length; i++) {
		var line = lines[i];
		var dllNameMatch = dllImportRegex.Match(line);
		if (!dllNameMatch.Success)
			continue;
		var dllName = dllNameMatch.Groups[1].Captures[0].Value;
		if (dllName != "__MonoRuntime")
			continue;

		var entryPointMatch = entryPointRegex.Match(line);
		if (entryPointMatch.Success) {
			entrypoints.Add(entryPointMatch.Groups[1].Captures[0].Value);
			continue;
		}

		i++;
		line = lines[i];
		var nameMatch = nameRegex.Match(line);
		if (nameMatch.Success) {
			entrypoints.Add(nameMatch.Groups[1].Captures[0].Value);
			continue;
		}
	}
}
#>
//
// THIS FILE HAS BEEN GENERATED BY A TOOL
// DO NOT UPDATE MANUALLY
//
// Copyright (c) Microsoft Corporation.  All Rights Reserved.
// See LICENSE.txt in the plugin root for license information.

#include "MonoRuntimeCommon.h"
#include "IMonoRuntime.h"
#include "PInvokeSignatures.h"
#include "CoreMinimal.h"
#include <mono/utils/mono-dl-fallback.h>

static TMap<FString,void*> MonoPInvokeFunctionMap_MonoRuntime;

static void MonoPInvokeRegisterFunctions_MonoRuntime()
{
<#foreach(var ep in entrypoints) { #>
	MonoPInvokeFunctionMap_MonoRuntime.Add(FString(TEXT("<#=ep#>")), (void*)<#=ep#>);
<#}#>
}

void* MonoPInvokeLoadLib(const char *name, int flags, char **err, void *user_data)
{
	FString LibName = FString(ANSI_TO_TCHAR(name));

	if (LibName == FString(TEXT("__MonoRuntime")))
	{
		if (MonoPInvokeFunctionMap_MonoRuntime.Num() == 0)
		{
			MonoPInvokeRegisterFunctions_MonoRuntime();
		}
		return &MonoPInvokeFunctionMap_MonoRuntime;
	}

	return nullptr;
}

void* MonoPInvokeGetSymbol(void *handle, const char *name, char **err, void *user_data)
{
	auto Map = reinterpret_cast<TMap<FString, void*>*> (handle);
	FString SymbolName = FString(ANSI_TO_TCHAR(name));
	void **Value = Map->Find(SymbolName);
	if (Value)
		return *Value;
	return nullptr;
}

MonoDlFallbackHandler * handler;

void MonoRegisterDllImportMappings()
{
	handler = mono_dl_fallback_register(MonoPInvokeLoadLib, MonoPInvokeGetSymbol, nullptr, nullptr);
}