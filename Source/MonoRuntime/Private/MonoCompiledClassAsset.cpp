// Copyright (c) Microsoft Corporation.  All Rights Reserved.
// See LICENSE.txt in the plugin root for license information.

#include "MonoCompiledClassAsset.h"

#include "UObject/Stack.h"
#include "UObject/ScriptMacros.h"

#include "MonoRuntimeCommon.h"
#include "MonoBindings.h"
#include "MonoHelpers.h"

TUniquePtr<FMonoCompiledClassAsset> FMonoCompiledClassAsset::CreateCompiledClassAsset(FString& ErrorString, 
																					  FMonoBindings& InBindings, 
																					  MonoClass* InAssetClass)
{
	MonoMethod* InAssetConstructor = Mono::LookupMethodOnClass(InAssetClass, ":.ctor(ObjectInitializer)");
	if (nullptr == InAssetConstructor)
	{
		ErrorString = FString::Printf(TEXT("Could not find constructor of form %s(ObjectInitializer initializer)"), ANSI_TO_TCHAR(mono_class_get_name(InAssetClass)));

		return TUniquePtr<FMonoCompiledClassAsset>();
	}

#if MONO_WITH_HOT_RELOADING
	MonoMethod* InAssetNativeConstructor = Mono::LookupMethodOnClass(InAssetClass, ":.ctor(intptr)");
	// This is an internal error as this constructor is generated by MonoAssemblyProcess, and the user adding this constructor would be the exact wrong thing to do.
	checkf(InAssetNativeConstructor, TEXT("Could not find generated constructor of form %s(IntPtr). Was MonoAssemblyProcess run on this assembly?"), ANSI_TO_TCHAR(mono_class_get_name(InAssetClass)));
#endif // MONO_WITH_HOT_RELOADING

	return TUniquePtr<FMonoCompiledClassAsset>(
		new FMonoCompiledClassAsset(InBindings, 
							InAssetClass, 
							InAssetConstructor
#if MONO_WITH_HOT_RELOADING
							, InAssetNativeConstructor
#endif // MONO_WITH_HOT_RELOADING
							));
}

FMonoCompiledClassAsset::FMonoCompiledClassAsset(FMonoBindings& InBindings, 
												MonoClass* InAssetClass, 
												MonoMethod* InAssetConstructor
#if MONO_WITH_HOT_RELOADING
												,MonoMethod* InAssetNativeConstructor
#endif // MONO_WITH_HOT_RELOADING
												)
: Bindings(InBindings)
, AssetClass(InAssetClass)
, AssetConstructor(InAssetConstructor)
#if MONO_WITH_HOT_RELOADING
, AssetNativeConstructor(InAssetNativeConstructor)
#endif // MONO_WITH_HOT_RELOADING
{
	check(AssetClass);
	check(AssetConstructor);

	BindInputMethod = Mono::LookupMethodOnClass(AssetClass, ":BindInput(InputComponent)");
	
}

void FMonoCompiledClassAsset::CreateCompanionObject(UObject* NativeObject, const FObjectInitializer& ObjectInitializer) const
{
	Bindings.CreateCompanionObject(NativeObject, AssetClass, AssetConstructor, ObjectInitializer);
}

void FMonoCompiledClassAsset::InvokeMonoEvent(UObject* Object, FFrame& Stack, RESULT_DECL)
{
	UFunction* Func = Stack.CurrentNativeFunction;

	uint8* ParamBuffer = nullptr;
	if (Stack.Code)
	{
		ParamBuffer = (uint8*)FMemory_Alloca(Func->ParmsSize);
		for (TFieldIterator<UProperty> ParamIt(Func, EFieldIteratorFlags::ExcludeSuper); ParamIt; ++ParamIt)
		{
			UProperty* Param = *ParamIt;
			Stack.Step(Stack.Object, ParamBuffer + Param->GetOffset_ForUFunction());
		}

		P_FINISH;
	}
	else
	{
		ParamBuffer = Stack.Locals;
	}
	
	void* Arguments[] =
	{ 
		&ParamBuffer,
		(void*)&RESULT_PARAM 
	};

	MonoMethod* EventMethod = MonoEventMap.FindChecked(Func);
	check(EventMethod);

	MonoObject* ObjectWrapper = Bindings.GetUnrealObjectWrapper(Object);
	check(ObjectWrapper);

	bool bThrewException = false;
	Mono::Invoke(bThrewException, Bindings.GetExceptionBehavior(), Bindings.GetDomain(), EventMethod, ObjectWrapper, Arguments);

	// Copy out parameters from the stack back into the UFunction parameter buffer.
	// Unfortunately, we can't just iterate over TheStack.OutParms because the list isn't NULL-terminated on non-debug builds.
	// It may be worth submitting a pull request to address this if the nested loop to find each out parameter's FOutParmRec
    // becomes a performance issue, but in practice, it should generally be a pretty short list.  The engine doesn't need it 
    // NULL-terminated because it's only ever used to look up CPF_OutParm UProperties that are guaranteed to be found.
	UProperty* ReturnProperty = NULL;
	if (Func->HasAnyFunctionFlags(FUNC_HasOutParms))
	{
		for (TFieldIterator<UProperty> ParamIt(Func, EFieldIteratorFlags::ExcludeSuper); ParamIt; ++ParamIt)
		{
			UProperty* ParamProperty = *ParamIt;

			// The return value is always flagged as an out parameter, but needs to be handled a little differently,
			// so just save it for later.
			if (ParamProperty->HasAnyPropertyFlags(CPF_ReturnParm))
			{
				ReturnProperty = ParamProperty;
			}
			else if (ParamProperty->HasAnyPropertyFlags(CPF_OutParm))
			{
				FOutParmRec* OutParmRec = Stack.OutParms;
				check(OutParmRec);
				while (OutParmRec->Property != ParamProperty)
				{
					OutParmRec = OutParmRec->NextOutParm;
				}

				uint8* ParmMemory = reinterpret_cast<uint8*>(ParamBuffer)+ParamProperty->GetOffset_ForUFunction();
				ParamProperty->InitializeValue(OutParmRec->PropAddr);
				ParamProperty->CopyCompleteValue(OutParmRec->PropAddr, ParmMemory);

				if (ParamProperty->IsA(UStrProperty::StaticClass()) || ParamProperty->IsA(UArrayProperty::StaticClass()))
				{
					FMarshalledScriptArray* RawArray = reinterpret_cast<FMarshalledScriptArray*>(ParmMemory);
					
					Mono::CoTaskMemFree(RawArray->Data);

					RawArray->ArrayMax = RawArray->ArrayNum = 0;
					RawArray->Data = nullptr;
				}
			}
		}
	}
	else
	{
		// FUNC_HasOutParms doesn't apply if the return value is the function's only property with the CPF_OutParm flag,
		// so we have to fetch it manually in that case.
		ReturnProperty = Func->GetReturnProperty();
	}

	// Result is already a pointer into the UFunction parameter buffer, so we don't need to copy anything in the general case,
	// but we do need to shuffle some things around if there were any dynamic allocations involved in the marshaling.
	if (ReturnProperty &&
		(ReturnProperty->IsA(UStrProperty::StaticClass()) || ReturnProperty->IsA(UArrayProperty::StaticClass())))
	{
		// Make a shallow copy of the marshaled array data, so we can clobber the original data with a proper Unreal type.
		FMarshalledScriptArray RawArray(*reinterpret_cast<FMarshalledScriptArray*>(RESULT_PARAM));

		ReturnProperty->InitializeValue(RESULT_PARAM);
		ReturnProperty->CopyCompleteValue(RESULT_PARAM, &RawArray);

		Mono::CoTaskMemFree(RawArray.Data);
	}

	// TODO: exceptions?
}

bool FMonoCompiledClassAsset::InvokeBindInput(UObject& Object, UInputComponent& InputComponent)
{
	if (BindInputMethod)
	{
		MonoObject* ObjectWrapper = Bindings.GetUnrealObjectWrapper(&Object);
		check(ObjectWrapper);

		Mono::Invoke<void>(Bindings, BindInputMethod, ObjectWrapper, &InputComponent);

		return true;
	}

	return false;
}

TArray<FLifetimeProperty> FMonoCompiledClassAsset::InvokeGetLifetimeReplicationList(UObject& Object)
{
	MonoMethod* LifetimeReplicationListMethod = Bindings.GetLifetimeReplicationListMethod();
	check(LifetimeReplicationListMethod);

	MonoObject* ObjectWrapper = Bindings.GetUnrealObjectWrapper(&Object);
	check(ObjectWrapper);

	return Mono::Invoke<TArray<FLifetimeProperty>>(Bindings, LifetimeReplicationListMethod, ObjectWrapper);
}

struct FCustomReplicatedPropertyActivation
{
	uint16 RepIndex;
	bool bActive;
};
// We implement the marshaling logic here instead of in MonoHelpers to keep the marshaling struct internal to this compilation unit,
// but the template specialization must still be declared within the same namespace.
namespace Mono
{
	template<>
	struct Marshal < TArray<FCustomReplicatedPropertyActivation>, void >
	{
		static TArray<FCustomReplicatedPropertyActivation> ReturnValue(const FMonoBindings& Bindings, MonoObject* Object)
		{
			TArray<FCustomReplicatedPropertyActivation> Ret;
			MonoValueArrayToTArray(Ret, Object);
			return Ret;
		}

		static inline bool IsValidParameterType(MonoType* typ)
		{
			return false;
		}

		static inline bool IsValidReturnType(MonoType* typ)
		{
			return IsValidArrayType(typ, MONO_BINDINGS_NAMESPACE ".CustomReplicatedPropertyActivation", false);
		}
	};
}

void FMonoCompiledClassAsset::InvokeUpdateCustomLifetimeReplicatedProperties(UObject& Object, IRepChangedPropertyTracker& ChangedPropertyTracker)
{
	MonoMethod* CustomReplicationListMethod = Bindings.GetCustomReplicationListMethod();
	check(CustomReplicationListMethod);

	MonoObject* ObjectWrapper = Bindings.GetUnrealObjectWrapper(&Object);
	check(ObjectWrapper);

	TArray<FCustomReplicatedPropertyActivation> ActivationState = Mono::Invoke<TArray<FCustomReplicatedPropertyActivation>>(Bindings, CustomReplicationListMethod, ObjectWrapper);
	for (auto& State : ActivationState)
	{
		ChangedPropertyTracker.SetCustomIsActiveOverride(State.RepIndex, State.bActive);
	}
}

FString FMonoCompiledClassAsset::GetQualifiedName() const
{
	const FString ClassName(mono_class_get_name(AssetClass));
	const FString Namespace(mono_class_get_namespace(AssetClass));

	if (Namespace.Len() > 0)
	{
		return FString::Printf(TEXT("%s.%s"), *Namespace, *ClassName);
	}
	else
	{
		return ClassName;
	}
}

FString FMonoCompiledClassAsset::GetName() const
{
	return FString(mono_class_get_name(AssetClass));
}

FString FMonoCompiledClassAsset::GetNamespace() const
{
	return FString(mono_class_get_namespace(AssetClass));
}

void FMonoCompiledClassAsset::AddFunctionsToEventMap(UMonoUnrealClass* Class, UClass* NativeParentClass, const TArray<FMonoFunctionMetadata>& FunctionMetadata)
{
	MonoClass* SearchClass = AssetClass;
	check(SearchClass);

	for (TFieldIterator<UFunction> It(Class, EFieldIteratorFlags::IncludeSuper); It; ++It)
	{
		UFunction* Func = *It;

		MonoClass* CurMonoClass = SearchClass;
		MonoMethod* Method = nullptr;
		FName FunctionFName = Func->GetFName();
		FString FunctionName = FunctionFName.ToString();
		for (auto& MetadataIt : FunctionMetadata)
		{
			// If the name is defined in C#, the capitalization might be different because FName can change capitalization
			// In order to find the right method pointer, Mono needs the original
			if (MetadataIt.Name == FunctionFName)
				FunctionName = MetadataIt.NameCaseSensitive;
		}
		FString MonoInvokerName = FString::Printf(TEXT("Invoke_%s"), *FunctionName);
		while (Method == nullptr && CurMonoClass != nullptr)
		{
			Method = Mono::LookupMethodOnClass(CurMonoClass, TCHAR_TO_ANSI(*FString::Printf(TEXT(":%s"), *MonoInvokerName)));
			CurMonoClass = mono_class_get_parent(CurMonoClass);
		}

		checkf(Method || NativeParentClass->IsChildOf(Func->GetOuterUClass()), 
			TEXT("Could not find method %s for function %s on class %s or its ancestors%s."), 
			*MonoInvokerName,
			*FunctionName,
			ANSI_TO_TCHAR(mono_class_get_name(SearchClass)), 
			SearchClass == AssetClass ? TEXT("") : *FString::Printf(TEXT(" for derived class %s"), ANSI_TO_TCHAR(mono_class_get_name(AssetClass))));
		MonoEventMap.Add(Func, Method);
	}

}
